---
title: "从 JS 转换到 ReScript"
description: "How to convert to ReScript with an existing JS codebase"
canonical: "/docs/manual/latest/converting-from-js"
---

<!--
# Converting from JS
-->
# 从 JS 转换到 ReScript

<!--
ReScript offers a unique project conversion methodology which:
- Ensures minimal disruption to your teammates (very important!).
- Remove the typical friction of verifying conversion's correctness and performance guarantees.
- Doesn't force you to search for pre-made binding libraries made by others. **ReScript doesn't need the equivalent of TypeScript's `DefinitelyTyped`**.
-->

ReScript 提供了一种独特的项目转换方式，这种转换方式：
- 确保对你的团队成员造成最小的干扰（非常重要！）。
- 消除了典型的验证转换正确性与保证性能的分歧。
- 不强制你寻找别人编写的预制绑定库。**ReScript 不需要等价于 TypeScript 的 `DefinitelyTyped` 东西**

<!--
## Step 1: Install ReScript
-->
## 步骤 1：安装 ReScript

<!--
Run `npm install rescript --save-dev` on your project, then imitate our [New Project](installation#new-project) workflow by adding a `bsconfig.json` at the root. Then start `npx rescript build -w`.
-->
在你的项目中运行 `npm install rescript --save-dev`，然后像我们在[新项目](installation#new-project)中的工作流程一样，将 `bsconfig.json` 添加到项目根目录。接着执行 `npx rescript build -w`。

<!--
## Step 2: Copy Paste the Entire JS File
-->

## 步骤 2：复制粘贴整个 JS 文件

<!--
Let's work on converting a file called `src/main.js`.
-->

让我们转换 `src/main.js` 这个文件。

```js
const school = require('school');

const defaultId = 10;

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
```

<!--
First, copy the entire file content over to a new file called `src/Main.res` by using our [`%%raw` JS embedding trick](embed-raw-javascript):
-->

首先，使用 [`%%raw` JS 嵌入技巧](embed-raw-javascript)，将整个文件的内容复制到新文件 `src/Main.res` 中：

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
%%raw(`
const school = require('school');

const defaultId = 10;

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
`)
```
```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

const school = require('school');

const defaultId = 10;

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}

/*  Not a pure module */
```

</CodeTab>

<!--
Add this file to `bsconfig.json`:
-->

将下面的内容添加到 `bsconfig.json`：

```json
  "sources": {
    "dir" : "src",
    "subdirs" : true
  },
```

<!--
Open an editor tab for `src/Main.bs.js`. Do a command-line `diff -u src/main.js src/Main.bs.js`. Aside from whitespaces, you should see only minimal, trivial differences. You're already a third of the way done!
-->

在编辑器中为 `src/Main.bs.js` 打开一个选项卡。执行命令 `diff -u src/main.js src/Main.bs.js`。除了空格以外，你应该只能看到一些极小的、微不足道的差别。你已经完成了三分之一的工作！

<!--
**Always make sure** that at each step, you keep the ReScript output `.bs.js` file open to compare against the existing JavaScript file. Our compilation output is very close to your hand-written JavaScript; you can simply eye the difference to catch conversion bugs!
-->

**始终确保**在每个步骤中保持打开 ReScript 输出的 `.bs.js` 文件，以便与现有的 JavaScript 文件进行比较。我们的编译输出与你手写的 JavaScript 非常接近；你可以通过简单地观察差异来发现转换 bug！

<!--
## Step 3: Extract Parts into Idiomatic ReScript
-->
## 步骤 3：将部分内容提取到 ReScript 中

<!--
Let's turn the `defaultId` variable into a ReScript let-binding:
-->

让我们将变量 `defaultId` 变成 ReScript 的 let 绑定：

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let defaultId = 10

%%raw(`
const school = require('school');

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}
`)
```
```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';


const school = require('school');

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return school.getStudentById(defaultId);
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
/*  Not a pure module */
```

</CodeTab>

<!--
Check the output. Diff it. Code still works. Moving on! Extract the function:
-->

检查输出。比较差异。代码仍然正确。那就继续前进！提取函数：

<CodeTab labels={["ReScript", "JS Output"]}>

```res
%%raw(`
const school = require('school');
`)

let defaultId = 10

let queryResult = (usePayload, payload) => {
  if usePayload {
    payload.student
  } else {
    school.getStudentById(defaultId)
  }
}
```
```js
```

</CodeTab>

<!--
Format the code: `./node_modules/.bin/rescript format src/Main.res`.
-->

格式化代码：`./node_modules/.bin/rescript format src/Main.res`。

<!--
We have a type error: "The record field student can't be found". That's fine! **Always ensure your code is syntactically valid first**. Fixing type errors comes later.
-->

我们得到了一个类型错误：“The record field student can't be found”。没关系！**始终优先确保你代码的语法是有效的**。稍后再修复类型错误。

<!--
## Step 4: Add `external`s, Fix Types
-->
## 步骤 4：添加 `external`，修复类型

<!--
The previous type error is caused by `payload`'s record declaration (which supposedly contains the field `student`) not being found. Since we're trying to convert as quickly as possible, let's use our [object](object) feature to avoid needing type declaration ceremonies:
-->

前面的类型错误是因为没有找到 `payload` 的记录声明（它应该包含 `student` 字段）造成的。因为我们想尽快地完成转换，让我们使用[对象](object)特性来避免类型体操：

<CodeTab labels={["ReScript", "JS Output"]}>

```res
%%raw(`
const school = require('school');
`)

let defaultId = 10

let queryResult = (usePayload, payload) => {
  if usePayload {
    payload["student"]
  } else {
    school["getStudentById"](defaultId)
  }
}
```
```js
```

</CodeTab>

<!--
Now this triggers the next type error, that `school` isn't found. Let's use [`external`](external) to bind to that module:
-->

现在这触发了下一个类型错误，即找不到 `school`。让我们使用 [`external`](external) 来绑定这个模块：

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
@module external school: 'whatever = "school"

let defaultId = 10

let queryResult = (usePayload, payload) => {
  if usePayload {
    payload["student"]
  } else {
    school["getStudentById"](defaultId)
  }
}
```
```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var School = require("school");

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return School.getStudentById(10);
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
exports.queryResult = queryResult;
/* school Not a pure module */
```

</CodeTab>

<!--
We hurrily typed `school` as a polymorphic `'whatever` and let its type be inferred by its usage below. The inference is technically correct, but within the context of bringing it a value from JavaScript, slightly dangerous. This is just the interop trick we've shown in the [`external`](external) page.
-->

我们匆忙地将 `school` 的类型变成了一个多态的 `'whatever`，并通过下面的用法推断其类型。这个推断在技术上是正确的，但因为 `school` 的值来自 JavaScript，这有些危险。这只是我们在 [`external`](external) 页面中展示的互操作技巧。

<!--
Anyway, the file passes the type checker again. Check the `.bs.js` output, diff with the original `.js`; we've now converted a file over to ReScript!
-->

总之，这个文件再次通过了类型检查器。检查 `.bs.js` 的输出，和原始的 `.js` 文件进行比较；我们现在将文件转换为了 ReScript！

<!--
Now, you can delete the original, hand-written `main.js` file, and grep the files importing `main.js` and change them to importing `Main.bs.js`.
-->

现在，你可以删除原始的、手写的 `main.js` 文件，然后 grep 导入了 `main.js` 的文件，将它们修改为导入 `Main.bs.js`。

<!--
## (Optional) Step 5: Cleanup
-->
## （可选）步骤 5：清理

<!--
If you prefer more advanced, rigidly typed `payload` and `school`, feel free to do so:
-->

如果你喜欢更高级、类型更严格的 `payload` 与 `school`，可以这样做：

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
type school
type student
type payload = {
  student: student
}

@module external school: school = "school"
@send external getStudentById: (school, int) => student = "getStudentById"

let defaultId = 10

let queryResult = (usePayload, payload) => {
  if usePayload {
    payload.student
  } else {
    school->getStudentById(defaultId)
  }
}
```
```js
// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var School = require("school");

function queryResult(usePayload, payload) {
  if (usePayload) {
    return payload.student;
  } else {
    return School.getStudentById(10);
  }
}

var defaultId = 10;

exports.defaultId = defaultId;
exports.queryResult = queryResult;
/* school Not a pure module */
```

</CodeTab>

<!--
We've:
- introduced an opaque types for `school` and `student` to prevent misusages their values
- typed the payload as a record with only the `student` field
- typed `getStudentById` as the sole method of `student`
-->

我们已经：
- 为 `school` 和 `student` 引入了一种不透明的类型，以防止误用它们的值
- 将 payload 声明为一个仅有 `student` 字段的记录
- 将 `getStudentById` 声明为 `student` 的唯一方法

<!--
Check that the `.bs.js` output didn't change. How rigidly to type your JavaScript code is up to you; we recommend not typing them too elaborately; it's sometime an endless chase, and produces diminishing returns, especially considering that the elaborate-ness might turn off your potential teammates.
-->

检查 `.bs.js` 的输出是否有变化。JavaScript 代码的类型严格程度取决于你；我们建议不要将它们的类型写的太详细；有时这就像是一个无底洞，产生的回报也会越来越少，特别是要考虑到过于精细设计可能会让你的一些潜在的队友不爽。

<!--
## Tips & Tricks
-->
### 技巧和诀窍

<!--
In the same vein of idea, **resist the urge to write your own wrapper functions for the JS code you're converting**. Use [`external`s](external), which are guaranteed to be erased in the output. And avoid trying to take the occasion to convert JS data structures into ReScript-specific data structures like variant or list. **This isn't the time for that**.
-->

本着同样的想法，**抑制为要转换的 JS 代码编写包装函数的冲动**。使用 [`external`](external)，它可以保证不会出现在输出中。并且避免尝试将 JS 的数据结构转换为 ReScript 特定的数据结构，像是变体（variant）或列表（list）。**现在不是做这个的时候**。

<!--
The moment you produce extra conversion code in the output, your skeptical teammate's mental model might switch from "I recognize this output" to "this conversion might be introducing more problems than it solves. Why are we testing ReScript again?". Then you've lost.
-->

一旦你在输出中产生了额外的转换代码，你那充满怀疑的队友的心智模型可能会从“我认识这个输出”变为“这个转换引入的问题可能比解决的问题多，我们为什么要再测试一遍 ReScript 代码？”。那么你就输了。

<!--
## Conclusion
-->
## 总结

<!--
- Paste the JS code into a new ReScript file as embedded raw JS code.
- Compile and keep the output file open. Check and diff against original JS file. Free regression tests.
- Always make sure your file is syntactically valid. Don't worry about fixing types before that.
- (Ab)use [object](object.md) accesses to quickly convert things over.
- Optionally clean up the types for robustness.
- Don't go overboard and turn off your boss and fellow teammates.
- Proudly display that you've conserved the semantics and performance characteristics during the conversion by showing your teammates the eerily familiar output.
- Get promoted for introducing a new technology the safer, mature way.
-->

- 将 JS 代码作为嵌入的原生 JS 代码粘贴到一个新的 ReScript 文件中。
- 编译并保持输出文件打开。检查代码并与原始 JS 文件进行比较。这是免费的回归测试。
- 始终确保你的文件在语法上是有效的。在此之前不要担心修复类型的问题。
- （滥）用[对象](object.md)访问来快速地完成转换。
- 整理类型（可选）以提高稳健性。
- 不要做的太过火而使你的老板与队友反感。
- 给你的队友展示异常熟悉的输出，自豪地表明你在转换中保留了语义与性能特征。
- 以更安全、更成熟的方式引入一项新技术，从而获得晋升。
