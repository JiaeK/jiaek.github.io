(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[57032],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},78091:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return u}});var a=n(17375),r=n(96156),o=(n(67294),n(3905));function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var l,p=(l="CodeTab",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",s({},e))}),c={};function u(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",s(s(s({},c),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",s({},{id:"extensible-variant"}),"Extensible Variant"),(0,o.kt)("p",null,"Variant types are usually constrained to a fixed set of constructors. There may be very rare cases where you still want to be able to add constructors to a variant type even after its initial type declaration. For this, we offer extensible variant types."),(0,o.kt)("h2",s({},{id:"definition-and-usage"}),"Definition and Usage"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type t = ..\n\ntype t += Other\n\ntype t +=\n  | Point(float, float)\n  | Line(float, float, float, float)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var Caml_exceptions = require("./stdlib/caml_exceptions.js");\n\nvar Other = Caml_exceptions.create("Playground.Other");\n\nvar Point = Caml_exceptions.create("Playground.Point");\n\nvar Line = Caml_exceptions.create("Playground.Line");\n'))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"..")," in the type declaration above defines an extensible variant ",(0,o.kt)("inlineCode",{parentName:"p"},"type t"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"+=")," operator is then used to add constructors to the given type. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Don't forget the leading ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," keyword when using the ",(0,o.kt)("inlineCode",{parentName:"p"},"+=")," operator!"),(0,o.kt)("h2",s({},{id:"pattern-matching-caveats"}),"Pattern Matching Caveats"),(0,o.kt)("p",null,"Extensible variants are open-ended, so the compiler will not be able to exhaustively pattern match all available cases. You will always need to provide a default ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," case for every ",(0,o.kt)("inlineCode",{parentName:"p"},"switch")," expression. "),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-res"}),'let print = v =>\n  switch v {\n  | Point(x, y) => Js.log2("Point", (x, y))\n  | Line(ax, ay, bx, by) => Js.log2("Line", (ax, ay, bx, by))\n  | Other\n  | _ => Js.log("Other")\n  }\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'function print(v) {\n  if (v.RE_EXN_ID === Point) {\n    console.log("Point", [v._1, v._2]);\n  } else if (v.RE_EXN_ID === Line) {\n    console.log("Line", [v._1, v._2, v._3, v._4]);\n  } else {\n    console.log("Other");\n  } \n}\n'))),(0,o.kt)("h2",s({},{id:"tips--tricks"}),"Tips & Tricks"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Fun fact:")," In ReScript, ",(0,o.kt)("a",s({parentName:"p"},{href:"./exception"}),"exceptions")," are actually extensible variants under the hood, so ",(0,o.kt)("inlineCode",{parentName:"p"},"exception UserError(string)")," is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"type exn += UserError(string)"),". It's one of the very few use-case where extensible variants make sense."),(0,o.kt)("p",null,"We usually recommend sticking with common ",(0,o.kt)("a",s({parentName:"p"},{href:"./variant"}),"variants")," as much as possible to reap the benefits of exhaustive pattern matching."))}u.isMDXComponent=!0,u.frontmatter={title:"Extensible Variant",description:"Extensible Variants in ReScript",canonical:"/docs/manual/latest/extensible-variant",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/extensible-variant.mdx"}},25361:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/extensible-variant",function(){return n(78091)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=25361,e(e.s=t);var t}));var t=e.O();_N_E=t}]);